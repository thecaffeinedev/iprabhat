I"‘<h1 id="test-driven-development">Test driven development</h1>

<p>If you want to understand the basics of the TDD, please read this <a href="https://www.freecodecamp.org/news/test-driven-development-what-it-is-and-what-it-is-not-41fa6bca02a2/">freecodecamp blog.</a></p>

<h3 id="3-rules-to-follow-while-doing-tdd">3 rules to follow while doing TDD</h3>

<ol>
  <li>Write production code only when there is a failing test.</li>
  <li>When writing failing test code, write only the minimum test code.</li>
  <li>If there is a failing test code, write only the minimum code that the code passes.</li>
</ol>

<h3 id="which-tests-should-i-write-first">Which tests should I write first?</h3>

<p><strong>Simplest, but interesting</strong> : Write the most concise and meaningful tests you can think of.</p>

<h3 id="order-of-tdd">Order of TDD</h3>

<p>red ‚û° green ‚û° refactor cycle</p>

<ol>
  <li>Start</li>
  <li>Writing the minimum code for failing test</li>
  <li>Writing passing prod minimal code</li>
  <li>Refactoring (go back to 2, if no more test cases come to mind, go to 5)</li>
  <li>Stop</li>
</ol>

<p><code class="language-plaintext highlighter-rouge">Note:</code> Step 4 is not optional. If step 4 is ignored, the code is dirty even after TDD.</p>

<p>Remember that refactoring is a natural and natural thing to do, comparable to washing your hands after using the bathroom.</p>

<h3 id="getting-stuck">Getting stuck</h3>

<p>There are times when you will get stuck during test-driven development. In this case, the writer runs into the idea that he can‚Äôt make all the test cases pass unless he erases and rewrites the existing code.</p>

<p>It is mainly caused by the following two cases.</p>

<ul>
  <li>you wrote the wrong test</li>
  <li>The prod code is too specific (mainly occurs if you do not follow the principle of Most simple, but interesting)</li>
</ul>

<h3 id="tdd-benefits">TDD Benefits</h3>

<ul>
  <li>Because the specification is set first and the prod code is implemented, the developer eliminates unnecessary thoughts when writing the code.</li>
  <li>Because we write the tests first, the code is decoupled. Naturally, a good design can be obtained.</li>
</ul>

<h3 id="ui-test">UI Test?</h3>

<p>Since the UI is exposed to too many changes, it can take more time and effort to write very specific test code.</p>

<p>Usually, UI tests are often omitted, and even if they are written, they are written very rough. Rough means that the React action is properly triggered and the style of the component with a certain text is changed as desired.</p>

<p>It is sometimes replaced with a visual regression test. A typical library for this is <a href="https://storybook.js.org/docs/guides/guide-react/">storybook</a> .</p>

<h3 id="practice-tdd">Practice TDD</h3>

<p>Just google ‚ÄúTDD kata‚Äù.¬†</p>

<h3 id="gradual-improvement">gradual improvement</h3>

<p>If you do TDD, you will naturally do refactoring, and if you separate modules by responsibility through refactoring, you will naturally get a good design. This is called gradual improvement.</p>

<p>What this means is that it is much more efficient to not get too hung up on design from the start, but to draw a rough design on the blackboard and then try to implement it directly. Because pretty diagrams can only be obtained when the implementation is complete.</p>

<p>According to someone who has actually experienced it, it goes something like this:</p>

<ol>
  <li>Write a test that passes</li>
  <li>Once implemented through TDD as per requirements</li>
  <li>Refactoring until the design is revealed through refactoring in TDD</li>
  <li>Looking at the architecture, separation of responsibilities. At this stage, all operations have already been performed successfully, and since the test has been obtained, changes are possible.</li>
  <li>refactoring</li>
  <li>Create a diagram to express your design</li>
</ol>

<h3 id="black-box-testing--white-box-testing">Black-box testing &amp; White-box testing</h3>

<ul>
  <li>White-box: Test the internal source code. Write tests for conditional statements in if/while and trace all executable paths.</li>
  <li>Black-box: A method of inspecting the operation without knowing the internal structure or principle of operation of the software, giving correct and incorrect inputs, and checking whether the software operates as expected.</li>
</ul>

<p>These are just some of my thoughts regarding it. I will write about it more clearly and in a structured way later on.</p>

<p><strong>Some good reads:</strong></p>

<ul>
  <li><a href="https://www.freecodecamp.org/news/test-driven-development-what-it-is-and-what-it-is-not-41fa6bca02a2/">freecodecamp blog</a></li>
  <li><a href="https://www.tddfellow.com/blog/2016/08/31/getting-stuck-while-doing-tdd-part-3-triangulation-to-the-rescue/">tddfellow</a></li>
  <li><a href="https://www.freecodecamp.org/news practical-tdd-test-driven-development-84a32044ed0b/">practical tdd</a></li>
  <li><a href="https://medium.com/javarevisited/tdd-katas-5e897300a887">kata blog</a></li>
</ul>
:ET